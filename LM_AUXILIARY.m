% -------------------------------------------------------------------------
% LM_AUXILIARY acts as the entry point from which all other code can be
% run based on TASK ids for special cases outside of the main pipeline
% contained in LM_CONTROLLER.
% -------------------------------------------------------------------------

function LM_AUXILIARY(TASK, INDEX, ALGORITHM, INPUT)

SETTINGS = LM_SETTINGS();
path = SETTINGS.filePath;

nL = SETTINGS.nLogics; % number of logics
nM = SETTINGS.nMotifs; % number of motifs
nP = SETTINGS.nParams; % number of parameter values
nS = SETTINGS.nStims;  % number of stimulus types
nN = SETTINGS.nNoises; % number of noise variations

if TASK > 7
    input = SETTINGS.inputNames{INPUT};
end

% Add folders.
addpath(genpath(SETTINGS.codePath));
addpath(SETTINGS.filePath);

switch TASK
    case 0
        s = [ '\n' ...
            '  TASK [1]: Calculate true edge weights using selected ALGORITHM' ...
            '\n  with hidden node representing the stimulus\n' ...
            '     INDEX : [1-' num2str(nM*nL*nS) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_M#L#S#_HIDDEN\n\n' ...
            '  TASK [2]: Calculate null edge weights using selected ALGORITHM' ...
            '\n  with hidden node representing the stimulus\n' ...
            '     INDEX : [1-' num2str(nN*nS*nP) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_N#S#A#_HIDDEN\n\n' ...
            '  TASK [3]: Compile null results for selected ALGORITHM' ...
            '\n  with hidden node representing the stimulus\n' ...
            '     INDEX : [1-' num2str(nN*nS) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_N#S#_HIDDEN\n\n' ...
            '  TASK [4]: Analyzes edge weights for selected ALGORITHM' ...
            '\n  with hidden node representing the stimulus\n' ...
            '     INDEX : [1-' num2str(nM*nL*nS) ']\n' ...
            '     Edge weights stored as Analysis_[ALGORITHM]_M#L#S#_HIDDEN\n\n' ...
            '  TASK [5]: Creates CSVs for hidden node results\n' ...
            '     CSVs are stored as [ALGORITHM]_[EDGE]_HIDDEN.csv\n\n' ...
            '  TASK [6]: Creates CSVs for statistical tests by timeslice\n' ...
            '     CSVs are stored as [ALGORITHM]_[EDGE]_SLICE.csv\n\n' ...
            '  TASK [7]: Creates CSVs for statistical tests by stimulus\n' ...
            '     CSVs are stored as [ALGORITHM]_[EDGE]_STIM.csv\n\n' ...
            '  TASK [8]: Simulate data for given motif and logic with'...
            '\n  selected INPUT stimulation type\n' ...
            '     INDEX : [1-' num2str(nM*nL) ']\n' ...
            '     Simulations stored as Simulations_M#L#_[INPUT]\n\n' ...
            '  TASK [9]: Consolidate simulations with selected INPUT' ...
            '\n  stimulation type\n' ...
            '     Cell array stored as Simulations_FULL_S#_[INPUT]\n\n' ...
            '  TASK [10]: Generate null models with selected INPUT' ...
            '\n  stimulation type\n' ...
            '     Cell array stored as Simulations_NULL_S#_[INPUT]\n\n' ...
            '  TASK [11]: Creates CSVs for simulation data for selected' ...
            '\n  INPUT stimulation type\n' ...
            '     CSVs are stored as M#L#S#N#I#.csv\n\n' ...
            '  TASK [12]: Calculate true edge weights using selected ALGORITHM' ...
            '\n  and INPUT stimulation type\n' ...
            '     INDEX : [1-' num2str(nM*nL*nS) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_M#L#S#_[INPUT]\n\n' ...
            '  TASK [13]: Calculate null edge weights using selected ALGORITHM' ...
            '\n  and INPUT stimulation type\n' ...
            '     INDEX : [1-' num2str(nN*nS*nP) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_N#S#A#_[INPUT]\n\n' ...
            '  TASK [14]: Compile null results for selected ALGORITHM' ...
            '\n  and INPUT stimulation type\n' ...
            '     INDEX : [1-' num2str(nN*nS) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_N#S#_[INPUT]\n\n' ...
            '  TASK [15]: Analyzes edge weights for selected ALGORITHM' ...
            '\n  and INPUT stimulation type\n' ...
            '     INDEX : [1-' num2str(nM*nL*nS) ']\n' ...
            '     Edge weights stored as Analysis_[ALGORITHM]_M#L#S#_[INPUT]\n\n' ...
            '  TASK [16]: Creates CSVs for inference data\n' ...
            '     CSVs are stored as [ALGORITHM]_M#L#S#N#T#_[INPUT].csv\n\n' ...
            '  TASK [17]: Creates CSVs for input results data\n' ...
            '     CSVs are stored as [ALGORITHM]_[EDGE]_INPUTS.csv\n\n' ...
            '  TASK [18]: Calculate true edge weights using selected ALGORITHM' ...
            '\n  and INPUT stimulation type and hidden node representing the stimulus\n' ...
            '     INDEX : [1-' num2str(nM*nL*nS) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_M#L#S#_[INPUT]_HIDDEN\n\n' ...
            '  TASK [19]: Calculate null edge weights using selected ALGORITHM' ...
            '\n  and INPUT stimulation type and hidden node representing the stimulus\n' ...
            '     INDEX : [1-' num2str(nN*nS*nP) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_N#S#A#_[INPUT]_HIDDEN\n\n' ...
            '  TASK [20]: Compile null results for selected ALGORITHM' ...
            '\n  and INPUT stimulation type and hidden node representing the stimulus\n' ...
            '     INDEX : [1-' num2str(nN*nS) ']\n' ...
            '     Edge weights stored as Results_[ALGORITHM]_N#S#_[INPUT]_HIDDEN\n\n' ...
            '  TASK [21]: Analyzes edge weights for selected ALGORITHM' ...
            '\n  and INPUT stimulation type and hidden node representing the stimulus\n' ...
            '     INDEX : [1-' num2str(nM*nL*nS) ']\n' ...
            '     Edge weights stored as Analysis_[ALGORITHM]_M#L#S#_[INPUT]_HIDDEN\n\n' ...
            '  TASK [22]: Creates CSVs for input and hidden results data\n' ...
            '     CSVs are stored as [ALGORITHM]_[EDGE]_BOTH.csv\n\n' ...
            '  TASK [23]: Creates CSVs for simulation chameleon\n' ...
            '     CSV stored as MERGED_SIMULATION.csv\n\n' ...
            '  TASK [24]: Creates CSVs for inference chameleon\n' ...
            '     CSV stored as [ALGORITHM]_MERGED_INFERENCE.csv\n\n' ...
            '\n'];
        fprintf(s);
% -------------------------------------------------------------------------
% HIDDEN NODE
% -------------------------------------------------------------------------
    case 1
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_run_algorithm(INDEX, ALGORITHM, true, 1);
        save([path 'Results_' ALGORITHM '_' code '_HIDDEN.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 2
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_run_nulls(INDEX, ALGORITHM, true, 1);
        save([path 'Results_' ALGORITHM '_' code '_HIDDEN.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 3
        index = (INDEX - 1)*nP + 1; % adjust index for parameter A values
        [output, code] = LM_compile_nulls(index, ALGORITHM, '_HIDDEN');
        save([path 'Results_' ALGORITHM '_' code(1:4) '_HIDDEN.mat'], '-struct', 'output');
    case 4
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_calc_metrics(INDEX, ALGORITHM, true, '_HIDDEN');
        save([path 'Analysis_' ALGORITHM '_' code '_HIDDEN.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 5
        LM_save_hidden(ALGORITHM);
% -------------------------------------------------------------------------
% STATISTICAL TESTING
% -------------------------------------------------------------------------
    case 6
        LM_save_stats(1, ALGORITHM);
    case 7
        LM_save_stats(2, ALGORITHM);
% -------------------------------------------------------------------------
% MODIFIED STIMULUS INPUTS
% -------------------------------------------------------------------------
    case 8
        dir = start_parpool(SETTINGS, nP);
        for i = 1:36
            index = (i - 1)*nS + 1; % adjust index for stimulation types
            [output, code] = LM_simulate_data(index, INPUT);
            save([path 'Simulations_' code(1:4) input '.mat'], '-struct', 'output');
        end
        stop_parpool(dir);
    case 9
        for iStim = 1:nS
            for i = 1:(nM*nL)
                [code, iMotif, iLogic, ~] = get_code((i - 1)*nS + 1, 1);
                fprintf('Processing STIM[%d] MOTIF[%d] GATE[%d]\n', iStim, iMotif, iLogic);
                d = load([path 'Simulations_' code(1:4) input]);
                
                for iNoise = 1:nN
                    noise = SETTINGS.noiseNames{iNoise};
                    output.(noise){iMotif, iLogic} = d.(noise)(:, :, iStim);
                end
            end
            
            save([path 'Simulations_FULL_S' num2str(iStim) input '.mat'], '-struct', 'output');
        end
    case 10
        dir = start_parpool(SETTINGS, nP);
        for iStim = 1:nS
            output = LM_generate_nulls(iStim, input);
            save([path 'Simulations_NULL_S' num2str(iStim) input '.mat'], '-struct', 'output');
        end
        stop_parpool(dir);
    case 11
        LM_save_simulations(input, ['_I' num2str(INPUT)]);
    case 12
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_run_algorithm(INDEX, ALGORITHM, false, INPUT);
        save([path 'Results_' ALGORITHM '_' code input '.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 13
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_run_nulls(INDEX, ALGORITHM, false, INPUT);
        save([path 'Results_' ALGORITHM '_' code input '.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 14
        index = (INDEX - 1)*nP + 1;
        [output, code] = LM_compile_nulls(index, ALGORITHM, input);
        save([path 'Results_' ALGORITHM '_' code(1:4) input '.mat'], '-struct', 'output');
    case 15
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_calc_metrics(INDEX, ALGORITHM, false, input);
        save([path 'Analysis_' ALGORITHM '_' code input '.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 16
        LM_save_inference(ALGORITHM, input);
    case 17
        LM_save_inputs(ALGORITHM);
% -------------------------------------------------------------------------
% MODIFIED STIMULUS INPUTS WITH HIDDEN NODE
% -------------------------------------------------------------------------
    case 18
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_run_algorithm(INDEX, ALGORITHM, true, INPUT);
        save([path 'Results_' ALGORITHM '_' code input '_HIDDEN.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 19
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_run_nulls(INDEX, ALGORITHM, true, INPUT);
        save([path 'Results_' ALGORITHM '_' code input '_HIDDEN.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 20
        index = (INDEX - 1)*nP + 1;
        [output, code] = LM_compile_nulls(index, ALGORITHM, [input '_HIDDEN']);
        save([path 'Results_' ALGORITHM '_' code(1:4) input '_HIDDEN.mat'], '-struct', 'output');
    case 21
        dir = start_parpool(SETTINGS, nP);
        [output, code] = LM_calc_metrics(INDEX, ALGORITHM, true, [input '_HIDDEN']);
        save([path 'Analysis_' ALGORITHM '_' code input '_HIDDEN.mat'], '-struct', 'output');
        stop_parpool(dir);
    case 22
        LM_save_both(ALGORITHM);
% -------------------------------------------------------------------------
% MERGED
% -------------------------------------------------------------------------
    case 23
        LM_merge_simulation();
    case 24
        LM_merge_inference(ALGORITHM);
    case 25
        LM_merge_difference(ALGORITHM, 1, 3, 'AC');
        LM_merge_difference(ALGORITHM, 2, 3, 'BC');
    case 26
        LM_merge_interval(ALGORITHM);
    case 27
        LM_merge_stimulus(ALGORITHM);
    case 28
        output = LM_merge_validation(ALGORITHM);
        save([path 'Validation_' ALGORITHM '.mat'], '-struct', 'output');
end

end